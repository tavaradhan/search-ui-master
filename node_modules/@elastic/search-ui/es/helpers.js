import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["field", "values", "type"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import deepEqual from "deep-equal";
/**
 * Given a list of applied Filters, find FilterValues based on
 * "fieldName" and "filterType".
 *
 * @param {*} filters
 * @param {*} name
 * @param {*} filterType
 */

export function findFilterValues(filters, name, filterType) {
  var filter = filters.find(function (f) {
    return f.field === name && f.type === filterType;
  });
  if (!filter) return [];
  return filter.values;
}
/**
 * Given a list of applied Filters, remove a single FilterValue based on
 * "fieldName" and "filterType".
 *
 * @param {Filter[]} filters
 * @param {String} fieldName
 * @param {FilterValue} value
 * @param {FilterType} filterType
 */

export function removeSingleFilterValue(filters, fieldName, value, filterType) {
  return filters.reduce(function (acc, filter) {
    var field = filter.field,
        values = filter.values,
        type = filter.type,
        rest = _objectWithoutProperties(filter, _excluded);

    if (field === fieldName && (!filterType || type === filterType)) {
      var updatedFilterValues = values.filter(function (filterValue) {
        return !doFilterValuesMatch(filterValue, value);
      });

      if (updatedFilterValues.length > 0) {
        return acc.concat(_objectSpread({
          field: field,
          values: updatedFilterValues,
          type: type
        }, rest));
      } else {
        return acc;
      }
    }

    return acc.concat(filter);
  }, []);
}
/**
 * Given a Facet and a list of applied Filters, mark the Facet Values
 * for that Facet as "selected" based on "fieldName" and "filterType".
 *
 * @param {Facet} facet
 * @param {String} fieldName
 * @param {Filter[]} filters
 * @param {FilterType} filterType
 */

export function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {
  var facetValues = facet.data;
  var filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];
  return _objectSpread(_objectSpread({}, facet), {}, {
    data: facetValues.map(function (facetValue) {
      return _objectSpread(_objectSpread({}, facetValue), {}, {
        selected: filterValuesForField.some(function (filterValue) {
          return doFilterValuesMatch(filterValue, facetValue.value);
        })
      });
    })
  });
}
/**
 * Useful for determining when filter values match. This could be used
 * when matching applied filters back to facet options, or for determining
 * whether or not a filter already exists in a list of applied filters.
 *
 * @param {FilterValue} filterValue1
 * @param {FilterValue} filterValue2
 */

export function doFilterValuesMatch(filterValue1, filterValue2) {
  if (filterValue1 && filterValue1.name && filterValue2 && filterValue2.name && filterValue1.name === filterValue2.name) // If two filters have matching names, then they are the same filter, there
    // is no need to do a more expensive deep equal comparison.
    //
    // This is also important because certain filters and facets will have
    // differing values than their corresponding facet options. For instance,
    // consider a time-based facet like "Last 10 Minutes". The value of the
    // filter will be different depending on when it was selected, but the name
    // will always match.
    return true; // We use 'strict = true' to do a '===' of leaves, rather than '=='

  return deepEqual(filterValue1, filterValue2, {
    strict: true
  });
} // Mix unique filter type from one array into the other

export function mergeFilters(filters1, filters2) {
  if (!filters2) return filters1;
  return filters2.reduce(function (acc, next) {
    if (acc.find(function (f) {
      return f.type === next.type && f.field === next.field;
    })) {
      return acc;
    }

    return [].concat(_toConsumableArray(acc), [next]);
  }, filters1);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxwZXJzLmpzIl0sIm5hbWVzIjpbImRlZXBFcXVhbCIsImZpbmRGaWx0ZXJWYWx1ZXMiLCJmaWx0ZXJzIiwibmFtZSIsImZpbHRlclR5cGUiLCJmaWx0ZXIiLCJmaW5kIiwiZiIsImZpZWxkIiwidHlwZSIsInZhbHVlcyIsInJlbW92ZVNpbmdsZUZpbHRlclZhbHVlIiwiZmllbGROYW1lIiwidmFsdWUiLCJyZWR1Y2UiLCJhY2MiLCJyZXN0IiwidXBkYXRlZEZpbHRlclZhbHVlcyIsImZpbHRlclZhbHVlIiwiZG9GaWx0ZXJWYWx1ZXNNYXRjaCIsImxlbmd0aCIsImNvbmNhdCIsIm1hcmtTZWxlY3RlZEZhY2V0VmFsdWVzRnJvbUZpbHRlcnMiLCJmYWNldCIsImZhY2V0VmFsdWVzIiwiZGF0YSIsImZpbHRlclZhbHVlc0ZvckZpZWxkIiwibWFwIiwiZmFjZXRWYWx1ZSIsInNlbGVjdGVkIiwic29tZSIsImZpbHRlclZhbHVlMSIsImZpbHRlclZhbHVlMiIsInN0cmljdCIsIm1lcmdlRmlsdGVycyIsImZpbHRlcnMxIiwiZmlsdGVyczIiLCJuZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxPQUFPQSxTQUFQLE1BQXNCLFlBQXRCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxPQUFPLFNBQVNDLGdCQUFULENBQTBCQyxPQUExQixFQUFtQ0MsSUFBbkMsRUFBeUNDLFVBQXpDLEVBQXFEO0FBQzFELE1BQU1DLE1BQU0sR0FBR0gsT0FBTyxDQUFDSSxJQUFSLENBQWEsVUFBQUMsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0MsS0FBRixLQUFZTCxJQUFaLElBQW9CSSxDQUFDLENBQUNFLElBQUYsS0FBV0wsVUFBbkM7QUFBQSxHQUFkLENBQWY7QUFDQSxNQUFJLENBQUNDLE1BQUwsRUFBYSxPQUFPLEVBQVA7QUFDYixTQUFPQSxNQUFNLENBQUNLLE1BQWQ7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNB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LFFBQVA7QUFFZixTQUFPQyxRQUFRLENBQUN0QixNQUFULENBQWdCLFVBQUNDLEdBQUQsRUFBTXNCLElBQU4sRUFBZTtBQUNwQyxRQUFJdEIsR0FBRyxDQUFDVCxJQUFKLENBQVMsVUFBQUMsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ0UsSUFBRixLQUFXNEIsSUFBSSxDQUFDNUIsSUFBaEIsSUFBd0JGLENBQUMsQ0FBQ0MsS0FBRixLQUFZNkIsSUFBSSxDQUFDN0IsS0FBN0M7QUFBQSxLQUFWLENBQUosRUFBbUU7QUFDakUsYUFBT08sR0FBUDtBQUNEOztBQUNELHdDQUFXQSxHQUFYLElBQWdCc0IsSUFBaEI7QUFDRCxHQUxNLEVBS0pGLFFBTEksQ0FBUDtBQU1EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZXBFcXVhbCBmcm9tIFwiZGVlcC1lcXVhbFwiO1xuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBhcHBsaWVkIEZpbHRlcnMsIGZpbmQgRmlsdGVyVmFsdWVzIGJhc2VkIG9uXG4gKiBcImZpZWxkTmFtZVwiIGFuZCBcImZpbHRlclR5cGVcIi5cbiAqXG4gKiBAcGFyYW0geyp9IGZpbHRlcnNcbiAqIEBwYXJhbSB7Kn0gbmFtZVxuICogQHBhcmFtIHsqfSBmaWx0ZXJUeXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlsdGVyVmFsdWVzKGZpbHRlcnMsIG5hbWUsIGZpbHRlclR5cGUpIHtcbiAgY29uc3QgZmlsdGVyID0gZmlsdGVycy5maW5kKGYgPT4gZi5maWVsZCA9PT0gbmFtZSAmJiBmLnR5cGUgPT09IGZpbHRlclR5cGUpO1xuICBpZiAoIWZpbHRlcikgcmV0dXJuIFtdO1xuICByZXR1cm4gZmlsdGVyLnZhbHVlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgYXBwbGllZCBGaWx0ZXJzLCByZW1vdmUgYSBzaW5nbGUgRmlsdGVyVmFsdWUgYmFzZWQgb25cbiAqIFwiZmllbGROYW1lXCIgYW5kIFwiZmlsdGVyVHlwZVwiLlxuICpcbiAqIEBwYXJhbSB7RmlsdGVyW119IGZpbHRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWVcbiAqIEBwYXJhbSB7RmlsdGVyVmFsdWV9IHZhbHVlXG4gKiBAcGFyYW0ge0ZpbHRlclR5cGV9IGZpbHRlclR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVNpbmdsZUZpbHRlclZhbHVlKGZpbHRlcnMsIGZpZWxkTmFtZSwgdmFsdWUsIGZpbHRlclR5cGUpIHtcbiAgcmV0dXJuIGZpbHRlcnMucmVkdWNlKChhY2MsIGZpbHRlcikgPT4ge1xuICAgIGNvbnN0IHsgZmllbGQsIHZhbHVlcywgdHlwZSwgLi4ucmVzdCB9ID0gZmlsdGVyO1xuICAgIGlmIChmaWVsZCA9PT0gZmllbGROYW1lICYmICghZmlsdGVyVHlwZSB8fCB0eXBlID09PSBmaWx0ZXJUeXBlKSkge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbHRlclZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoXG4gICAgICAgIGZpbHRlclZhbHVlID0+ICFkb0ZpbHRlclZhbHVlc01hdGNoKGZpbHRlclZhbHVlLCB2YWx1ZSlcbiAgICAgICk7XG4gICAgICBpZiAodXBkYXRlZEZpbHRlclZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KHtcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICB2YWx1ZXM6IHVwZGF0ZWRGaWx0ZXJWYWx1ZXMsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZmlsdGVyKTtcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRmFjZXQgYW5kIGEgbGlzdCBvZiBhcHBsaWVkIEZpbHRlcnMsIG1hcmsgdGhlIEZhY2V0IFZhbHVlc1xuICogZm9yIHRoYXQgRmFjZXQgYXMgXCJzZWxlY3RlZFwiIGJhc2VkIG9uIFwiZmllbGROYW1lXCIgYW5kIFwiZmlsdGVyVHlwZVwiLlxuICpcbiAqIEBwYXJhbSB7RmFjZXR9IGZhY2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lXG4gKiBAcGFyYW0ge0ZpbHRlcltdfSBmaWx0ZXJzXG4gKiBAcGFyYW0ge0ZpbHRlclR5cGV9IGZpbHRlclR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtTZWxlY3RlZEZhY2V0VmFsdWVzRnJvbUZpbHRlcnMoXG4gIGZhY2V0LFxuICBmaWx0ZXJzLFxuICBmaWVsZE5hbWUsXG4gIGZpbHRlclR5cGVcbikge1xuICBjb25zdCBmYWNldFZhbHVlcyA9IGZhY2V0LmRhdGE7XG4gIGNvbnN0IGZpbHRlclZhbHVlc0ZvckZpZWxkID1cbiAgICBmaW5kRmlsdGVyVmFsdWVzKGZpbHRlcnMsIGZpZWxkTmFtZSwgZmlsdGVyVHlwZSkgfHwgW107XG4gIHJldHVybiB7XG4gICAgLi4uZmFjZXQsXG4gICAgZGF0YTogZmFjZXRWYWx1ZXMubWFwKGZhY2V0VmFsdWUgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmFjZXRWYWx1ZSxcbiAgICAgICAgc2VsZWN0ZWQ6IGZpbHRlclZhbHVlc0ZvckZpZWxkLnNvbWUoZmlsdGVyVmFsdWUgPT4ge1xuICAgICAgICAgIHJldHVybiBkb0ZpbHRlclZhbHVlc01hdGNoKGZpbHRlclZhbHVlLCBmYWNldFZhbHVlLnZhbHVlKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoZW4gZmlsdGVyIHZhbHVlcyBtYXRjaC4gVGhpcyBjb3VsZCBiZSB1c2VkXG4gKiB3aGVuIG1hdGNoaW5nIGFwcGxpZWQgZmlsdGVycyBiYWNrIHRvIGZhY2V0IG9wdGlvbnMsIG9yIGZvciBkZXRlcm1pbmluZ1xuICogd2hldGhlciBvciBub3QgYSBmaWx0ZXIgYWxyZWFkeSBleGlzdHMgaW4gYSBsaXN0IG9mIGFwcGxpZWQgZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0ge0ZpbHRlclZhbHVlfSBmaWx0ZXJWYWx1ZTFcbiAqIEBwYXJhbSB7RmlsdGVyVmFsdWV9IGZpbHRlclZhbHVlMlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG9GaWx0ZXJWYWx1ZXNNYXRjaChmaWx0ZXJWYWx1ZTEsIGZpbHRlclZhbHVlMikge1xuICBpZiAoXG4gICAgZmlsdGVyVmFsdWUxICYmXG4gICAgZmlsdGVyVmFsdWUxLm5hbWUgJiZcbiAgICBmaWx0ZXJWYWx1ZTIgJiZcbiAgICBmaWx0ZXJWYWx1ZTIubmFtZSAmJlxuICAgIGZpbHRlclZhbHVlMS5uYW1lID09PSBmaWx0ZXJWYWx1ZTIubmFtZVxuICApXG4gICAgLy8gSWYgdHdvIGZpbHRlcnMgaGF2ZSBtYXRjaGluZyBuYW1lcywgdGhlbiB0aGV5IGFyZSB0aGUgc2FtZSBmaWx0ZXIsIHRoZXJlXG4gICAgLy8gaXMgbm8gbmVlZCB0byBkbyBhIG1vcmUgZXhwZW5zaXZlIGRlZXAgZXF1YWwgY29tcGFyaXNvbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgYWxzbyBpbXBvcnRhbnQgYmVjYXVzZSBjZXJ0YWluIGZpbHRlcnMgYW5kIGZhY2V0cyB3aWxsIGhhdmVcbiAgICAvLyBkaWZmZXJpbmcgdmFsdWVzIHRoYW4gdGhlaXIgY29ycmVzcG9uZGluZyBmYWNldCBvcHRpb25zLiBGb3IgaW5zdGFuY2UsXG4gICAgLy8gY29uc2lkZXIgYSB0aW1lLWJhc2VkIGZhY2V0IGxpa2UgXCJMYXN0IDEwIE1pbnV0ZXNcIi4gVGhlIHZhbHVlIG9mIHRoZVxuICAgIC8vIGZpbHRlciB3aWxsIGJlIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hlbiBpdCB3YXMgc2VsZWN0ZWQsIGJ1dCB0aGUgbmFtZVxuICAgIC8vIHdpbGwgYWx3YXlzIG1hdGNoLlxuICAgIHJldHVybiB0cnVlO1xuICAvLyBXZSB1c2UgJ3N0cmljdCA9IHRydWUnIHRvIGRvIGEgJz09PScgb2YgbGVhdmVzLCByYXRoZXIgdGhhbiAnPT0nXG4gIHJldHVybiBkZWVwRXF1YWwoZmlsdGVyVmFsdWUxLCBmaWx0ZXJWYWx1ZTIsIHsgc3RyaWN0OiB0cnVlIH0pO1xufVxuXG4vLyBNaXggdW5pcXVlIGZpbHRlciB0eXBlIGZyb20gb25lIGFycmF5IGludG8gdGhlIG90aGVyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VGaWx0ZXJzKGZpbHRlcnMxLCBmaWx0ZXJzMikge1xuICBpZiAoIWZpbHRlcnMyKSByZXR1cm4gZmlsdGVyczE7XG5cbiAgcmV0dXJuIGZpbHRlcnMyLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgaWYgKGFjYy5maW5kKGYgPT4gZi50eXBlID09PSBuZXh0LnR5cGUgJiYgZi5maWVsZCA9PT0gbmV4dC5maWVsZCkpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIHJldHVybiBbLi4uYWNjLCBuZXh0XTtcbiAgfSwgZmlsdGVyczEpO1xufVxuIl19