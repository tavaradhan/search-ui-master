import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import { createBrowserHistory as createHistory } from "history";
import queryString from "./queryString";

function isNumericString(num) {
  return !isNaN(num);
}

function toSingleValue(val) {
  return Array.isArray(val) ? val[val.length - 1] : val;
}

function toSingleValueInteger(num) {
  return toInteger(toSingleValue(num));
}

function toInteger(num) {
  if (!isNumericString(num)) return;
  return parseInt(num, 10);
}

function parseFiltersFromQueryParams(queryParams) {
  return queryParams.filters;
}

function parseCurrentFromQueryParams(queryParams) {
  return toSingleValueInteger(queryParams.current);
}

function parseSearchTermFromQueryParams(queryParams) {
  return toSingleValue(queryParams.q);
}

function parseOldSortFromQueryParams(queryParams) {
  var sortField = toSingleValue(queryParams["sort-field"]);
  var sortDirection = toSingleValue(queryParams["sort-direction"]);
  if (sortField) return [sortField, sortDirection];
  return [];
}

function parseSizeFromQueryParams(queryParams) {
  return toSingleValueInteger(queryParams.size);
}

function parseSortFromQueryParams(queryParams) {
  return queryParams["sort"];
}

function paramsToState(queryParams) {
  var state = {
    current: parseCurrentFromQueryParams(queryParams),
    filters: parseFiltersFromQueryParams(queryParams),
    searchTerm: parseSearchTermFromQueryParams(queryParams),
    resultsPerPage: parseSizeFromQueryParams(queryParams),
    sortField: parseOldSortFromQueryParams(queryParams)[0],
    sortDirection: parseOldSortFromQueryParams(queryParams)[1],
    sortList: parseSortFromQueryParams(queryParams)
  };
  return Object.keys(state).reduce(function (acc, key) {
    var value = state[key];
    if (value) acc[key] = value;
    return acc;
  }, {});
}

function stateToParams(_ref) {
  var searchTerm = _ref.searchTerm,
      current = _ref.current,
      filters = _ref.filters,
      resultsPerPage = _ref.resultsPerPage,
      sortDirection = _ref.sortDirection,
      sortField = _ref.sortField,
      sortList = _ref.sortList;
  var params = {};
  if (current > 1) params.current = current;
  if (searchTerm) params.q = searchTerm;
  if (resultsPerPage) params.size = resultsPerPage;

  if (filters && filters.length > 0) {
    params["filters"] = filters;
  }

  if (sortList && sortList.length > 0) {
    params["sort"] = sortList;
  } else if (sortField) {
    params["sort-field"] = sortField;
    params["sort-direction"] = sortDirection;
  }

  return params;
}

function stateToQueryString(state) {
  return queryString.stringify(stateToParams(state));
}
/**
 * The URL Manager is responsible for synchronizing state between
 * SearchDriver and the URL. There are 3 main cases we handle when
 * synchronizing:
 *
 * 1. When the app loads, SearchDriver will need to
 * read the current state from the URL, in order to perform the search
 * expressed by the query string. `getStateFromURL` is used for this case.
 *
 * 2. When the URL changes as a result of `pushState` or `replaceState`,
 * SearchDriver will need to be notified and given the updated state, so that
 * it can re-run the current search. `onURLStateChange` is used for this case.
 *
 * 3. When state changes internally in the SearchDriver, as a result of an
 * Action, it will need to notify the URLManager of the change. `pushStateToURL`
 * is used for this case.
 */


var URLManager = /*#__PURE__*/function () {
  function URLManager() {
    _classCallCheck(this, URLManager);

    this.history = createHistory();
    this.lastPushSearchString = "";
  }
  /**
   * Parse the current URL into application state
   *
   * @return {Object} - The parsed state object
   */


  _createClass(URLManager, [{
    key: "getStateFromURL",
    value: function getStateFromURL() {
      return paramsToState(queryString.parse(this.history.location.search));
    }
    /**
     * Push the current state of the application to the URL
     *
     * @param {Object} state - The entire current state from the SearchDriver
     * @param {boolean} options
     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'
     * rather than 'push' to avoid adding a new history entry
     */

  }, {
    key: "pushStateToURL",
    value: function pushStateToURL(state) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$replaceUrl = _ref2.replaceUrl,
          replaceUrl = _ref2$replaceUrl === void 0 ? false : _ref2$replaceUrl;

      var searchString = stateToQueryString(state);
      this.lastPushSearchString = searchString;
      var navigationFunction = replaceUrl ? this.history.replace : this.history.push;
      navigationFunction({
        search: "?".concat(searchString)
      });
    }
    /**
     * Add an event handler to be executed whenever state is pushed to the URL
     *
     * @callback requestCallback
     * @param {Object} state - Updated application state parsed from the new URL
     *
     * @param {requestCallback} callback
     */

  }, {
    key: "onURLStateChange",
    value: function onURLStateChange(callback) {
      var _this = this;

      this.unlisten = this.history.listen(function (location) {
        // If this URL is updated as a result of a pushState request, we don't
        // want to notify that the URL changed.
        if ("?".concat(_this.lastPushSearchString) === location.search) return; // Once we've decided to return based on lastPushSearchString, reset
        // it so that we don't break back / forward button.

        _this.lastPushSearchString = "";
        callback(paramsToState(queryString.parse(location.search)));
      });
    }
  }, {
    key: "tearDown",
    value: function tearDown() {
      this.unlisten();
    }
  }]);

  return URLManager;
}();

export { URLManager as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9VUkxNYW5hZ2VyLmpzIl0sIm5hbWVzIjpbImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlSGlzdG9yeSIsInF1ZXJ5U3RyaW5nIiwiaXNOdW1lcmljU3RyaW5nIiwibnVtIiwiaXNOYU4iLCJ0b1NpbmdsZVZhbHVlIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidG9TaW5nbGVWYWx1ZUludGVnZXIiLCJ0b0ludGVnZXIiLCJwYXJzZUludCIsInBhcnNlRmlsdGVyc0Zyb21RdWVyeVBhcmFtcyIsInF1ZXJ5UGFyYW1zIiwiZmlsdGVycyIsInBhcnNlQ3VycmVudEZyb21RdWVyeVBhcmFtcyIsImN1cnJlbnQiLCJwYXJzZVNlYXJjaFRlcm1Gcm9tUXVlcnlQYXJhbXMiLCJxIiwicGFyc2VPbGRTb3J0RnJvbVF1ZXJ5UGFyYW1zIiwic29ydEZpZWxkIiwic29ydERpcmVjdGlvbiIsInBhcnNlU2l6ZUZyb21RdWVyeVBhcmFtcyIsInNpemUiLCJwYXJzZVNvcnRGcm9tUXVlcnlQYXJhbXMiLCJwYXJhbXNUb1N0YXRlIiwic3RhdGUiLCJzZWFyY2hUZXJtIiwicmVzdWx0c1BlclBhZ2UiLCJzb3J0TGlzdCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJ2YWx1ZSIsInN0YXRlVG9QYXJhbXMiLCJwYXJhbXMiLCJzdGF0ZVRvUXVlcnlTdHJpbmciLCJzdHJpbmdpZnkiLCJVUkxNYW5hZ2VyIiwiaGlzdG9yeSIsImxhc3RQdXNoU2VhcmNoU3RyaW5nIiwicGFyc2UiLCJsb2NhdGlvbiIsInNlYXJjaCIsInJlcGxhY2VVcmwiLCJzZWFyY2hTdHJpbmciLCJuYXZpZ2F0aW9uRnVuY3Rpb24iLCJyZXBsYWNlIiwicHVzaCIsImNhbGxiYWNrIiwidW5saXN0ZW4iLCJsaXN0ZW4iXSwibWFwcGluZ3MiOiI7O0FBQUEsU0FBU0Esb0JBQW9CLElBQUlDLGFBQWpDLFFBQXNELFNBQXREO0FBQ0EsT0FBT0MsV0FBUCxN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O0FBRUFTLFFBQUFBLFFBQVEsQ0FBQzFCLGFBQWEsQ0FBQ3pCLFdBQVcsQ0FBQzJDLEtBQVosQ0FBa0JDLFFBQVEsQ0FBQ0MsTUFBM0IsQ0FBRCxDQUFkLENBQVI7QUFDRCxPQVZlLENBQWhCO0FBV0Q7OztXQUVELG9CQUFXO0FBQ1QsV0FBS08sUUFBTDtBQUNEOzs7Ozs7U0ExRGtCWixVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnkgYXMgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgcXVlcnlTdHJpbmcgZnJvbSBcIi4vcXVlcnlTdHJpbmdcIjtcblxuZnVuY3Rpb24gaXNOdW1lcmljU3RyaW5nKG51bSkge1xuICByZXR1cm4gIWlzTmFOKG51bSk7XG59XG5cbmZ1bmN0aW9uIHRvU2luZ2xlVmFsdWUodmFsKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWxbdmFsLmxlbmd0aCAtIDFdIDogdmFsO1xufVxuXG5mdW5jdGlvbiB0b1NpbmdsZVZhbHVlSW50ZWdlcihudW0pIHtcbiAgcmV0dXJuIHRvSW50ZWdlcih0b1NpbmdsZVZhbHVlKG51bSkpO1xufVxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gIGlmICghaXNOdW1lcmljU3RyaW5nKG51bSkpIHJldHVybjtcbiAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnNGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpIHtcbiAgcmV0dXJuIHF1ZXJ5UGFyYW1zLmZpbHRlcnM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3VycmVudEZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykge1xuICByZXR1cm4gdG9TaW5nbGVWYWx1ZUludGVnZXIocXVlcnlQYXJhbXMuY3VycmVudCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2VhcmNoVGVybUZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykge1xuICByZXR1cm4gdG9TaW5nbGVWYWx1ZShxdWVyeVBhcmFtcy5xKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VPbGRTb3J0RnJvbVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSB7XG4gIGNvbnN0IHNvcnRGaWVsZCA9IHRvU2luZ2xlVmFsdWUocXVlcnlQYXJhbXNbXCJzb3J0LWZpZWxkXCJdKTtcbiAgY29uc3Qgc29ydERpcmVjdGlvbiA9IHRvU2luZ2xlVmFsdWUocXVlcnlQYXJhbXNbXCJzb3J0LWRpcmVjdGlvblwiXSk7XG5cbiAgaWYgKHNvcnRGaWVsZCkgcmV0dXJuIFtzb3J0RmllbGQsIHNvcnREaXJlY3Rpb25dO1xuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2l6ZUZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykge1xuICByZXR1cm4gdG9TaW5nbGVWYWx1ZUludGVnZXIocXVlcnlQYXJhbXMuc2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU29ydEZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykge1xuICByZXR1cm4gcXVlcnlQYXJhbXNbXCJzb3J0XCJdO1xufVxuXG5mdW5jdGlvbiBwYXJhbXNUb1N0YXRlKHF1ZXJ5UGFyYW1zKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGN1cnJlbnQ6IHBhcnNlQ3VycmVudEZyb21RdWVyeVBhcmFtcyhxdWVyeVBhcmFtcyksXG4gICAgZmlsdGVyczogcGFyc2VGaWx0ZXJzRnJvbVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSxcbiAgICBzZWFyY2hUZXJtOiBwYXJzZVNlYXJjaFRlcm1Gcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpLFxuICAgIHJlc3VsdHNQZXJQYWdlOiBwYXJzZVNpemVGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpLFxuICAgIHNvcnRGaWVsZDogcGFyc2VPbGRTb3J0RnJvbVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKVswXSxcbiAgICBzb3J0RGlyZWN0aW9uOiBwYXJzZU9sZFNvcnRGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpWzFdLFxuICAgIHNvcnRMaXN0OiBwYXJzZVNvcnRGcm9tUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpXG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZVtrZXldO1xuICAgIGlmICh2YWx1ZSkgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlVG9QYXJhbXMoe1xuICBzZWFyY2hUZXJtLFxuICBjdXJyZW50LFxuICBmaWx0ZXJzLFxuICByZXN1bHRzUGVyUGFnZSxcbiAgc29ydERpcmVjdGlvbixcbiAgc29ydEZpZWxkLFxuICBzb3J0TGlzdFxufSkge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKGN1cnJlbnQgPiAxKSBwYXJhbXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gIGlmIChzZWFyY2hUZXJtKSBwYXJhbXMucSA9IHNlYXJjaFRlcm07XG4gIGlmIChyZXN1bHRzUGVyUGFnZSkgcGFyYW1zLnNpemUgPSByZXN1bHRzUGVyUGFnZTtcbiAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgcGFyYW1zW1wiZmlsdGVyc1wiXSA9IGZpbHRlcnM7XG4gIH1cbmlmIChzb3J0TGlzdCAmJiBzb3J0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgcGFyYW1zW1wic29ydFwiXSA9IHNvcnRMaXN0O1xuICB9IGVsc2UgaWYgKHNvcnRGaWVsZCkge1xuICAgIHBhcmFtc1tcInNvcnQtZmllbGRcIl0gPSBzb3J0RmllbGQ7XG4gICAgcGFyYW1zW1wic29ydC1kaXJlY3Rpb25cIl0gPSBzb3J0RGlyZWN0aW9uO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmZ1bmN0aW9uIHN0YXRlVG9RdWVyeVN0cmluZyhzdGF0ZSkge1xuICByZXR1cm4gcXVlcnlTdHJpbmcuc3RyaW5naWZ5KHN0YXRlVG9QYXJhbXMoc3RhdGUpKTtcbn1cblxuLyoqXG4gKiBUaGUgVVJMIE1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIHN5bmNocm9uaXppbmcgc3RhdGUgYmV0d2VlblxuICogU2VhcmNoRHJpdmVyIGFuZCB0aGUgVVJMLiBUaGVyZSBhcmUgMyBtYWluIGNhc2VzIHdlIGhhbmRsZSB3aGVuXG4gKiBzeW5jaHJvbml6aW5nOlxuICpcbiAqIDEuIFdoZW4gdGhlIGFwcCBsb2FkcywgU2VhcmNoRHJpdmVyIHdpbGwgbmVlZCB0b1xuICogcmVhZCB0aGUgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBVUkwsIGluIG9yZGVyIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICogZXhwcmVzc2VkIGJ5IHRoZSBxdWVyeSBzdHJpbmcuIGBnZXRTdGF0ZUZyb21VUkxgIGlzIHVzZWQgZm9yIHRoaXMgY2FzZS5cbiAqXG4gKiAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlcyBhcyBhIHJlc3VsdCBvZiBgcHVzaFN0YXRlYCBvciBgcmVwbGFjZVN0YXRlYCxcbiAqIFNlYXJjaERyaXZlciB3aWxsIG5lZWQgdG8gYmUgbm90aWZpZWQgYW5kIGdpdmVuIHRoZSB1cGRhdGVkIHN0YXRlLCBzbyB0aGF0XG4gKiBpdCBjYW4gcmUtcnVuIHRoZSBjdXJyZW50IHNlYXJjaC4gYG9uVVJMU3RhdGVDaGFuZ2VgIGlzIHVzZWQgZm9yIHRoaXMgY2FzZS5cbiAqXG4gKiAzLiBXaGVuIHN0YXRlIGNoYW5nZXMgaW50ZXJuYWxseSBpbiB0aGUgU2VhcmNoRHJpdmVyLCBhcyBhIHJlc3VsdCBvZiBhblxuICogQWN0aW9uLCBpdCB3aWxsIG5lZWQgdG8gbm90aWZ5IHRoZSBVUkxNYW5hZ2VyIG9mIHRoZSBjaGFuZ2UuIGBwdXNoU3RhdGVUb1VSTGBcbiAqIGlzIHVzZWQgZm9yIHRoaXMgY2FzZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVUkxNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeSgpO1xuICAgIHRoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmcgPSBcIlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBjdXJyZW50IFVSTCBpbnRvIGFwcGxpY2F0aW9uIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgcGFyc2VkIHN0YXRlIG9iamVjdFxuICAgKi9cbiAgZ2V0U3RhdGVGcm9tVVJMKCkge1xuICAgIHJldHVybiBwYXJhbXNUb1N0YXRlKHF1ZXJ5U3RyaW5nLnBhcnNlKHRoaXMuaGlzdG9yeS5sb2NhdGlvbi5zZWFyY2gpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhcHBsaWNhdGlvbiB0byB0aGUgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBlbnRpcmUgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBTZWFyY2hEcml2ZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yZXBsYWNlVXJsIC0gV2hlbiBwdXNoaW5nIHN0YXRlIHRvIHRoZSBVUkwsIHVzZSBoaXN0b3J5ICdyZXBsYWNlJ1xuICAgKiByYXRoZXIgdGhhbiAncHVzaCcgdG8gYXZvaWQgYWRkaW5nIGEgbmV3IGhpc3RvcnkgZW50cnlcbiAgICovXG4gIHB1c2hTdGF0ZVRvVVJMKHN0YXRlLCB7IHJlcGxhY2VVcmwgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBzZWFyY2hTdHJpbmcgPSBzdGF0ZVRvUXVlcnlTdHJpbmcoc3RhdGUpO1xuICAgIHRoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmc7XG4gICAgY29uc3QgbmF2aWdhdGlvbkZ1bmN0aW9uID0gcmVwbGFjZVVybFxuICAgICAgPyB0aGlzLmhpc3RvcnkucmVwbGFjZVxuICAgICAgOiB0aGlzLmhpc3RvcnkucHVzaDtcbiAgICBuYXZpZ2F0aW9uRnVuY3Rpb24oe1xuICAgICAgc2VhcmNoOiBgPyR7c2VhcmNoU3RyaW5nfWBcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlciB0byBiZSBleGVjdXRlZCB3aGVuZXZlciBzdGF0ZSBpcyBwdXNoZWQgdG8gdGhlIFVSTFxuICAgKlxuICAgKiBAY2FsbGJhY2sgcmVxdWVzdENhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFVwZGF0ZWQgYXBwbGljYXRpb24gc3RhdGUgcGFyc2VkIGZyb20gdGhlIG5ldyBVUkxcbiAgICpcbiAgICogQHBhcmFtIHtyZXF1ZXN0Q2FsbGJhY2t9IGNhbGxiYWNrXG4gICAqL1xuICBvblVSTFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51bmxpc3RlbiA9IHRoaXMuaGlzdG9yeS5saXN0ZW4obG9jYXRpb24gPT4ge1xuICAgICAgLy8gSWYgdGhpcyBVUkwgaXMgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZiBhIHB1c2hTdGF0ZSByZXF1ZXN0LCB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBub3RpZnkgdGhhdCB0aGUgVVJMIGNoYW5nZWQuXG4gICAgICBpZiAoYD8ke3RoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmd9YCA9PT0gbG9jYXRpb24uc2VhcmNoKSByZXR1cm47XG5cbiAgICAgIC8vIE9uY2Ugd2UndmUgZGVjaWRlZCB0byByZXR1cm4gYmFzZWQgb24gbGFzdFB1c2hTZWFyY2hTdHJpbmcsIHJlc2V0XG4gICAgICAvLyBpdCBzbyB0aGF0IHdlIGRvbid0IGJyZWFrIGJhY2sgLyBmb3J3YXJkIGJ1dHRvbi5cbiAgICAgIHRoaXMubGFzdFB1c2hTZWFyY2hTdHJpbmcgPSBcIlwiO1xuXG4gICAgICBjYWxsYmFjayhwYXJhbXNUb1N0YXRlKHF1ZXJ5U3RyaW5nLnBhcnNlKGxvY2F0aW9uLnNlYXJjaCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRlYXJEb3duKCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfVxufVxuIl19