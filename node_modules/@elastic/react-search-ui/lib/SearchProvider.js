"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _searchUi = require("@elastic/search-ui");

var _SearchContext = _interopRequireDefault(require("./SearchContext"));

var _A11yNotifications = _interopRequireDefault(require("./A11yNotifications"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * The SearchProvider primarily holds a reference to the SearchDriver and
 * exposes it to the rest of the application in a Context.
 */
var SearchProvider = function SearchProvider(_ref) {
  var children = _ref.children,
      _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config,
      driver = _ref.driver;

  var _useState = (0, _react.useState)(null),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      driverInstance = _useState2[0],
      setDriverInstance = _useState2[1];

  (0, _react.useEffect)(function () {
    // This initialization is done inside of useEffect, because initializing the SearchDriver server side
    // will error out, since the driver depends on window. Placing the initialization inside of useEffect
    // assures that it won't attempt to initialize server side.
    var currentDriver = driver || new _searchUi.SearchDriver(_objectSpread(_objectSpread({}, config), {}, {
      a11yNotificationMessages: _objectSpread(_objectSpread({}, _A11yNotifications.default), config.a11yNotificationMessages)
    }));
    setDriverInstance(currentDriver);
    return function () {
      currentDriver.tearDown();
    };
  }, []); // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,
  // which would be destructive. An example of why this is useful is dynamically updating facets.

  (0, _react.useEffect)(function () {
    if (driverInstance) {
      driverInstance.setSearchQuery(config.searchQuery);
    }
  }, [config.searchQuery]);
  (0, _react.useEffect)(function () {
    if (driverInstance) {
      driverInstance.setAutocompleteQuery(config.autocompleteQuery);
    }
  }, [config.autocompleteQuery]); // Since driver is initialized in useEffect above, we are waiting
  // to render until the driver is available.

  if (!driverInstance) return null; // Passing the entire "this.state" to the Context is significant. Because
  // Context determines when to re-render based on referential identity
  // something like this could cause unnecessary renders:
  //
  // <SearchContext.Provider value={{driver: this.state.driver}}>
  //
  // By passing the entire state, we ensure that re-renders only occur when
  // state is actually updated.

  return /*#__PURE__*/_react.default.createElement(_SearchContext.default.Provider, {
    value: {
      driver: driverInstance
    }
  }, children);
};

SearchProvider.propTypes = {
  children: _propTypes.default.node.isRequired,
  // Not providing a shape here because the shape matches the shape of
  // SearchDriver. SearchDriver can do it's own parameter validation.
  config: _propTypes.default.object,
  driver: _propTypes.default.object
};
var _default = SearchProvider;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TZWFyY2hQcm92aWRlci5qcyJdLCJuYW1lcyI6WyJTZWFyY2hQcm92aWRlciIsImNoaWxkcmVuIiwiY29uZmlnIiwiZHJpdmVyIiwiZHJpdmVySW5zdGFuY2UiLCJzZXREcml2ZXJJbnN0YW5jZSIsImN1cnJlbnREcml2ZXIiLCJTZWFyY2hEcml2ZXIiLCJhMTF5Tm90aWZpY2F0aW9uTWVzc2FnZXMiLCJkZWZhdWx0QTExeU1lc3NhZ2VzIiwidGVhckRvd24iLCJzZXRTZWFyY2hRdWVyeSIsInNlYXJjaFF1ZXJ5Iiwic2V0QXV0b2NvbXBsZXRlUXVlcnkiLCJhdXRvY29tcGxldGVRdWVyeSIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm5vZGUiLCJpc1JlcXVpcmVkIiwib2JqZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQixPQUF1QztBQUFBLE1BQXBDQyxRQUFvQyxRQUFwQ0EsUUFBb0M7QUFBQSx5QkFBMUJDLE1BQTBCO0FBQUEsTUFBMUJBLE1BQTBCLDRCQUFqQixFQUFpQjtBQUFBLE1BQWJDLE1BQWEsUUFBYkEsTUFBYTs7QUFDNUQsa0JBQTRDLHFCQUFTLElBQVQsQ0FBNUM7QUFBQTtBQUFBLE1BQU9DLGNBQVA7QUFBQSxNQUF1QkMsaUJBQXZCOztBQUVBLHdCQUFVLFlBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxhQUFhLEdBQ2pCSCxNQUFNLElBQ04sSUFBSUksc0JBQUosaUNBQ0tMLE1BREw7QUFFRU0sTUFBQUEsd0JBQXdCLGtDQUNuQkMsMEJBRG1CLEdBRW5CUCxNQUFNLENBQUNNLHdCQUZZO0FBRjFCLE9BRkY7QUFTQUgsSUFBQUEsaUJBQWlCLENBQUNDLGFBQUQsQ0FBakI7QUFFQSxXQUFPLFlBQU07QUFDWEEsTUFBQUEsYUFBYSxDQUFDSSxRQUFkO0FBQ0QsS0FGRDtBQUdELEdBbEJELEVBa0JHLEVBbEJILEVBSDRELENBdUI1RDtBQUNBOztBQUNBLHdCQUFVLFlBQU07QUFDZCxRQUFJTixjQUFKLEVBQW9CO0FBQ2xCQSxNQUFBQSxjQUFjLENBQUNPLGNBQWYsQ0FBOEJULE1BQU0sQ0FBQ1UsV0FBckM7QUFDRDtBQUNGLEdBSkQsRUFJRyxDQUFDVixNQUFNLENBQUNVLFdBQVIsQ0FKSDtBQU1BLHdCQUFVLFlBQU07QUFDZCxRQUFJUixjQUFKLEVBQW9CO0FBQ2xCQSxNQUFBQSxjQUFjLENBQUNTLG9CQUFmLENBQW9DWCxNQUFNLENBQUNZLGlCQUEzQztBQUNEO0FBQ0YsR0FKRCxFQUlHLENBQUNaLE1BQU0sQ0FBQ1ksaUJBQVIsQ0FKSCxFQS9CNEQsQ0FxQzVEO0FBQ0E7O0FBQ0EsTUFBSSxDQUFDVixjQUFMLEVBQXFCLE9BQU8sSUFBUCxDQXZDdUMsQ0F5QzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Esc0JBQ0UsNkJBQUMsc0JBQUQsQ0FBZSxRQUFmO0FBQXdCLElBQUEsS0FBSyxFQUFFO0FBQUVELE1BQUFBLE1BQU0sRUFBRUM7QUFBVjtBQUEvQixLQUNHSCxRQURILENBREY7QUFLRCxDQXRERDs7QUF3REFELGNBQWMsQ0FBQ2UsU0FBZixHQUEyQjtBQUN6QmQsRUFBQUEsUUFBUSxFQUFFZSxtQkFBVUMsSUFBVixDQUFlQyxVQURBO0FBRXpCO0FBQ0E7QUFDQWhCLEVBQUFBLE1BQU0sRUFBRWMsbUJBQVVHLE1BSk87QUFLekJoQixFQUFBQSxNQUFNLEVBQUVhLG1CQUFVRztBQUxPLENBQTNCO2VBUWVuQixjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgU2VhcmNoRHJpdmVyIH0gZnJvbSBcIkBlbGFzdGljL3NlYXJjaC11aVwiO1xuaW1wb3J0IFNlYXJjaENvbnRleHQgZnJvbSBcIi4vU2VhcmNoQ29udGV4dFwiO1xuXG5pbXBvcnQgZGVmYXVsdEExMXlNZXNzYWdlcyBmcm9tIFwiLi9BMTF5Tm90aWZpY2F0aW9uc1wiO1xuXG4vKipcbiAqIFRoZSBTZWFyY2hQcm92aWRlciBwcmltYXJpbHkgaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIFNlYXJjaERyaXZlciBhbmRcbiAqIGV4cG9zZXMgaXQgdG8gdGhlIHJlc3Qgb2YgdGhlIGFwcGxpY2F0aW9uIGluIGEgQ29udGV4dC5cbiAqL1xuY29uc3QgU2VhcmNoUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgY29uZmlnID0ge30sIGRyaXZlciB9KSA9PiB7XG4gIGNvbnN0IFtkcml2ZXJJbnN0YW5jZSwgc2V0RHJpdmVySW5zdGFuY2VdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBUaGlzIGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW5zaWRlIG9mIHVzZUVmZmVjdCwgYmVjYXVzZSBpbml0aWFsaXppbmcgdGhlIFNlYXJjaERyaXZlciBzZXJ2ZXIgc2lkZVxuICAgIC8vIHdpbGwgZXJyb3Igb3V0LCBzaW5jZSB0aGUgZHJpdmVyIGRlcGVuZHMgb24gd2luZG93LiBQbGFjaW5nIHRoZSBpbml0aWFsaXphdGlvbiBpbnNpZGUgb2YgdXNlRWZmZWN0XG4gICAgLy8gYXNzdXJlcyB0aGF0IGl0IHdvbid0IGF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBzZXJ2ZXIgc2lkZS5cbiAgICBjb25zdCBjdXJyZW50RHJpdmVyID1cbiAgICAgIGRyaXZlciB8fFxuICAgICAgbmV3IFNlYXJjaERyaXZlcih7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgYTExeU5vdGlmaWNhdGlvbk1lc3NhZ2VzOiB7XG4gICAgICAgICAgLi4uZGVmYXVsdEExMXlNZXNzYWdlcyxcbiAgICAgICAgICAuLi5jb25maWcuYTExeU5vdGlmaWNhdGlvbk1lc3NhZ2VzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHNldERyaXZlckluc3RhbmNlKGN1cnJlbnREcml2ZXIpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnREcml2ZXIudGVhckRvd24oKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gVGhpcyBlZmZlY3QgYWxsb3dzIHVzZXJzIHRvIGR5bmFtaWNhbGx5IHVwZGF0ZSB0aGVpciBzZWFyY2hRdWVyeSB3aXRob3V0IHJlLW1vdW50aW5nIGEgU2VhcmNoUHJvdmlkZXIsXG4gIC8vIHdoaWNoIHdvdWxkIGJlIGRlc3RydWN0aXZlLiBBbiBleGFtcGxlIG9mIHdoeSB0aGlzIGlzIHVzZWZ1bCBpcyBkeW5hbWljYWxseSB1cGRhdGluZyBmYWNldHMuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRyaXZlckluc3RhbmNlKSB7XG4gICAgICBkcml2ZXJJbnN0YW5jZS5zZXRTZWFyY2hRdWVyeShjb25maWcuc2VhcmNoUXVlcnkpO1xuICAgIH1cbiAgfSwgW2NvbmZpZy5zZWFyY2hRdWVyeV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRyaXZlckluc3RhbmNlKSB7XG4gICAgICBkcml2ZXJJbnN0YW5jZS5zZXRBdXRvY29tcGxldGVRdWVyeShjb25maWcuYXV0b2NvbXBsZXRlUXVlcnkpO1xuICAgIH1cbiAgfSwgW2NvbmZpZy5hdXRvY29tcGxldGVRdWVyeV0pO1xuXG4gIC8vIFNpbmNlIGRyaXZlciBpcyBpbml0aWFsaXplZCBpbiB1c2VFZmZlY3QgYWJvdmUsIHdlIGFyZSB3YWl0aW5nXG4gIC8vIHRvIHJlbmRlciB1bnRpbCB0aGUgZHJpdmVyIGlzIGF2YWlsYWJsZS5cbiAgaWYgKCFkcml2ZXJJbnN0YW5jZSkgcmV0dXJuIG51bGw7XG5cbiAgLy8gUGFzc2luZyB0aGUgZW50aXJlIFwidGhpcy5zdGF0ZVwiIHRvIHRoZSBDb250ZXh0IGlzIHNpZ25pZmljYW50LiBCZWNhdXNlXG4gIC8vIENvbnRleHQgZGV0ZXJtaW5lcyB3aGVuIHRvIHJlLXJlbmRlciBiYXNlZCBvbiByZWZlcmVudGlhbCBpZGVudGl0eVxuICAvLyBzb21ldGhpbmcgbGlrZSB0aGlzIGNvdWxkIGNhdXNlIHVubmVjZXNzYXJ5IHJlbmRlcnM6XG4gIC8vXG4gIC8vIDxTZWFyY2hDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7ZHJpdmVyOiB0aGlzLnN0YXRlLmRyaXZlcn19PlxuICAvL1xuICAvLyBCeSBwYXNzaW5nIHRoZSBlbnRpcmUgc3RhdGUsIHdlIGVuc3VyZSB0aGF0IHJlLXJlbmRlcnMgb25seSBvY2N1ciB3aGVuXG4gIC8vIHN0YXRlIGlzIGFjdHVhbGx5IHVwZGF0ZWQuXG4gIHJldHVybiAoXG4gICAgPFNlYXJjaENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3sgZHJpdmVyOiBkcml2ZXJJbnN0YW5jZSB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1NlYXJjaENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5TZWFyY2hQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAvLyBOb3QgcHJvdmlkaW5nIGEgc2hhcGUgaGVyZSBiZWNhdXNlIHRoZSBzaGFwZSBtYXRjaGVzIHRoZSBzaGFwZSBvZlxuICAvLyBTZWFyY2hEcml2ZXIuIFNlYXJjaERyaXZlciBjYW4gZG8gaXQncyBvd24gcGFyYW1ldGVyIHZhbGlkYXRpb24uXG4gIGNvbmZpZzogUHJvcFR5cGVzLm9iamVjdCxcbiAgZHJpdmVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2hQcm92aWRlcjtcbiJdfQ==